/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Create API keys in your profile and use public API key as username and secret API key as password to authorize.
 *
 * 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Candle } from '../models';
import { CandleMulti } from '../models';
import { Currency } from '../models';
import { CurrencyMulti } from '../models';
import { FundingHistoryMulti } from '../models';
import { FuturesCandleMulti } from '../models';
import { FuturesInfo } from '../models';
import { FuturesInfoMulti } from '../models';
import { InlineResponse200 } from '../models';
import { InlineResponse2001 } from '../models';
import { Orderbook } from '../models';
import { OrderbookMulti } from '../models';
import { PriceHistoryMulti } from '../models';
import { PriceMulti } from '../models';
import { PublicTrade } from '../models';
import { PublicTradeMulti } from '../models';
import { Ticker } from '../models';
import { TickerMulti } from '../models';
import { TickerPrice } from '../models';
import { TickerPriceMulti } from '../models';
/**
 * MarketDataApi - axios parameter creator
 * @export
 */
export const MarketDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns candles for all or multiple symbols.
         * @summary Get candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesGet: async (symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/candles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns candles for a specific symbol.
         * @summary Get candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCandlesSymbolGet: async (symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicCandlesSymbolGet.');
            }
            const localVarPath = `/public/candles/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyCurrencyGet: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling publicCurrencyCurrencyGet.');
            }
            const localVarPath = `/public/currency/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the actual list of available currencies, tokens, etc.
         * @summary Get —Åurrencies.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCurrencyGet: async (currencies?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns index price candles for all or multiple contracts.
         * @summary Get index price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesIndexPriceGet: async (symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/candles/index_price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns index price candles for a specific contract.
         * @summary Get index price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesIndexPriceSymbolGet: async (symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesCandlesIndexPriceSymbolGet.');
            }
            const localVarPath = `/public/futures/candles/index_price/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns mark price candles for all or multiple contracts.
         * @summary Get mark price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesMarkPriceGet: async (symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/candles/mark_price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns mark price candles for a specific contract.
         * @summary Get mark price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesMarkPriceSymbolGet: async (symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesCandlesMarkPriceSymbolGet.');
            }
            const localVarPath = `/public/futures/candles/mark_price/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns open interest candles for all or multiple contracts.
         * @summary Get open interest candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesOpenInterestGet: async (symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/candles/open_interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns open interest candles for a specific symbol.
         * @summary Get open interest candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesOpenInterestSymbolGet: async (symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesCandlesOpenInterestSymbolGet.');
            }
            const localVarPath = `/public/futures/candles/open_interest/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns premium index candles for all or multiple contracts.
         * @summary Get premium index candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesPremiumIndexGet: async (symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/candles/premium_index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns premium index candles for a certain contract.
         * @summary Premium index candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesCandlesPremiumIndexSymbolGet: async (symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesCandlesPremiumIndexSymbolGet.');
            }
            const localVarPath = `/public/futures/candles/premium_index/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns funding history for all or multiple contracts.
         * @summary Get funding history.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesHistoryFundingGet: async (symbols?: Array<string>, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/history/funding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns funding history for a specific contract.
         * @summary Get funding history.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesHistoryFundingSymbolGet: async (symbol: string, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesHistoryFundingSymbolGet.');
            }
            const localVarPath = `/public/futures/history/funding/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns futures information for all or multiple contracts.
         * @summary Get futures information.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesInfoGet: async (symbols?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/futures/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns futures information for a specified contract.
         * @summary Get futures information for a contract.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicFuturesInfoSymbolGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicFuturesInfoSymbolGet.');
            }
            const localVarPath = `/public/futures/info/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns order book for all or multiple symbols.
         * @summary Get order books.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookGet: async (symbols?: Array<string>, depth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/orderbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The request returns an order book for a specific symbol.
         * @summary Get order book by symbol.
         * @param {string} symbol Symbol code.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {number} [volume] Desired volume for market depth search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicOrderbookSymbolGet: async (symbol: string, depth?: number, volume?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicOrderbookSymbolGet.');
            }
            const localVarPath = `/public/orderbook/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (volume !== undefined) {
                localVarQueryParameter['volume'] = volume;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns quotation prices history.
         * @summary Get prices history.
         * @param {string} to Target currency code.
         * @param {string} [from] Source currency code.
         * @param {string} [since] Interval initial value.
         * @param {string} [until] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {string} [period] 
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPriceHistoryGet: async (to: string, from?: string, since?: string, until?: string, limit?: number, period?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling publicPriceHistoryGet.');
            }
            const localVarPath = `/public/price/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns currencies quotation prices.
         * @summary Get prices.
         * @param {string} from Source currency code.
         * @param {string} to Target currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPriceRateGet: async (from: string, to: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling publicPriceRateGet.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling publicPriceRateGet.');
            }
            const localVarPath = `/public/price/rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns tickers' last prices for all symbols.
         * @summary Get ticker last prices.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPriceTickerGet: async (symbols?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/price/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the ticker last price for a specific symbol.
         * @summary Get ticker last price by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPriceTickerSymbolGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicPriceTickerSymbolGet.');
            }
            const localVarPath = `/public/price/ticker/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the actual list of currency symbols (currency pairs) traded on the exchange.
         * @summary Get symbols.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolGet: async (symbols?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/symbol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicSymbolSymbolGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicSymbolSymbolGet.');
            }
            const localVarPath = `/public/symbol/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns ticker information.
         * @summary Get tickers.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerGet: async (symbols?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the ticker for a specific symbol.
         * @summary Get ticker by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTickerSymbolGet: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicTickerSymbolGet.');
            }
            const localVarPath = `/public/ticker/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns trades information for all or multiple symbols.
         * @summary Get trades.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [by] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesGet: async (symbols?: Array<string>, by?: string, sort?: string, from?: Date, till?: Date, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbols) {
                localVarQueryParameter['symbols'] = symbols.join(COLLECTION_FORMATS.csv);
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns trades information for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [by] The name of the field to order the results by.
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicTradesSymbolGet: async (symbol: string, sort?: string, by?: string, from?: Date, till?: Date, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling publicTradesSymbolGet.');
            }
            const localVarPath = `/public/trades/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketDataApi - functional programming interface
 * @export
 */
export const MarketDataApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns candles for all or multiple symbols.
         * @summary Get candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCandlesGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CandleMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicCandlesGet(symbols, sort, period, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns candles for a specific symbol.
         * @summary Get candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCandlesSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Candle>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicCandlesSymbolGet(symbol, sort, period, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCurrencyCurrencyGet(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Currency>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicCurrencyCurrencyGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the actual list of available currencies, tokens, etc.
         * @summary Get —Åurrencies.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCurrencyGet(currencies?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CurrencyMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicCurrencyGet(currencies, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns index price candles for all or multiple contracts.
         * @summary Get index price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesIndexPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesCandleMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesIndexPriceGet(symbols, sort, period, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns index price candles for a specific contract.
         * @summary Get index price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesIndexPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Candle>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesIndexPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns mark price candles for all or multiple contracts.
         * @summary Get mark price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesMarkPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesCandleMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesMarkPriceGet(symbols, sort, period, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns mark price candles for a specific contract.
         * @summary Get mark price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesMarkPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Candle>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesMarkPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns open interest candles for all or multiple contracts.
         * @summary Get open interest candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesOpenInterestGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesCandleMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesOpenInterestGet(symbols, sort, period, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns open interest candles for a specific symbol.
         * @summary Get open interest candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesOpenInterestSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Candle>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesOpenInterestSymbolGet(symbol, sort, period, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns premium index candles for all or multiple contracts.
         * @summary Get premium index candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesPremiumIndexGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesCandleMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesPremiumIndexGet(symbols, sort, period, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns premium index candles for a certain contract.
         * @summary Premium index candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesPremiumIndexSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Candle>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesCandlesPremiumIndexSymbolGet(symbol, sort, period, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns funding history for all or multiple contracts.
         * @summary Get funding history.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesHistoryFundingGet(symbols?: Array<string>, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FundingHistoryMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesHistoryFundingGet(symbols, sort, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns funding history for a specific contract.
         * @summary Get funding history.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesHistoryFundingSymbolGet(symbol: string, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FundingHistoryMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesHistoryFundingSymbolGet(symbol, sort, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns futures information for all or multiple contracts.
         * @summary Get futures information.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesInfoGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesInfoMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesInfoGet(symbols, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns futures information for a specified contract.
         * @summary Get futures information for a contract.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesInfoSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FuturesInfo>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicFuturesInfoSymbolGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns order book for all or multiple symbols.
         * @summary Get order books.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicOrderbookGet(symbols?: Array<string>, depth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<OrderbookMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicOrderbookGet(symbols, depth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The request returns an order book for a specific symbol.
         * @summary Get order book by symbol.
         * @param {string} symbol Symbol code.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {number} [volume] Desired volume for market depth search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicOrderbookSymbolGet(symbol: string, depth?: number, volume?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Orderbook>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicOrderbookSymbolGet(symbol, depth, volume, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns quotation prices history.
         * @summary Get prices history.
         * @param {string} to Target currency code.
         * @param {string} [from] Source currency code.
         * @param {string} [since] Interval initial value.
         * @param {string} [until] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {string} [period] 
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceHistoryGet(to: string, from?: string, since?: string, until?: string, limit?: number, period?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PriceHistoryMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicPriceHistoryGet(to, from, since, until, limit, period, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns currencies quotation prices.
         * @summary Get prices.
         * @param {string} from Source currency code.
         * @param {string} to Target currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceRateGet(from: string, to: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PriceMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicPriceRateGet(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns tickers' last prices for all symbols.
         * @summary Get ticker last prices.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TickerPriceMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicPriceTickerGet(symbols, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the ticker last price for a specific symbol.
         * @summary Get ticker last price by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceTickerSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TickerPrice>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicPriceTickerSymbolGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the actual list of currency symbols (currency pairs) traded on the exchange.
         * @summary Get symbols.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicSymbolGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicSymbolGet(symbols, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicSymbolSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2001>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicSymbolSymbolGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns ticker information.
         * @summary Get tickers.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<TickerMulti>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicTickerGet(symbols, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the ticker for a specific symbol.
         * @summary Get ticker by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTickerSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Ticker>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicTickerSymbolGet(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns trades information for all or multiple symbols.
         * @summary Get trades.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [by] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTradesGet(symbols?: Array<string>, by?: string, sort?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PublicTradeMulti>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicTradesGet(symbols, by, sort, from, till, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns trades information for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [by] The name of the field to order the results by.
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTradesSymbolGet(symbol: string, sort?: string, by?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PublicTrade>>>> {
            const localVarAxiosArgs = await MarketDataApiAxiosParamCreator(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MarketDataApi - factory interface
 * @export
 */
export const MarketDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns candles for all or multiple symbols.
         * @summary Get candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCandlesGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<CandleMulti>> {
            return MarketDataApiFp(configuration).publicCandlesGet(symbols, sort, period, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns candles for a specific symbol.
         * @summary Get candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCandlesSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Candle>>> {
            return MarketDataApiFp(configuration).publicCandlesSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCurrencyCurrencyGet(currency: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Currency>> {
            return MarketDataApiFp(configuration).publicCurrencyCurrencyGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the actual list of available currencies, tokens, etc.
         * @summary Get —Åurrencies.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCurrencyGet(currencies?: Array<string>, options?: AxiosRequestConfig): Promise<AxiosResponse<CurrencyMulti>> {
            return MarketDataApiFp(configuration).publicCurrencyGet(currencies, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns index price candles for all or multiple contracts.
         * @summary Get index price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesIndexPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesCandleMulti>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesIndexPriceGet(symbols, sort, period, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns index price candles for a specific contract.
         * @summary Get index price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesIndexPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Candle>>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesIndexPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns mark price candles for all or multiple contracts.
         * @summary Get mark price candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesMarkPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesCandleMulti>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesMarkPriceGet(symbols, sort, period, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns mark price candles for a specific contract.
         * @summary Get mark price candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesMarkPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Candle>>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesMarkPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns open interest candles for all or multiple contracts.
         * @summary Get open interest candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesOpenInterestGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesCandleMulti>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesOpenInterestGet(symbols, sort, period, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns open interest candles for a specific symbol.
         * @summary Get open interest candles for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesOpenInterestSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Candle>>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesOpenInterestSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns premium index candles for all or multiple contracts.
         * @summary Get premium index candles.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesPremiumIndexGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesCandleMulti>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesPremiumIndexGet(symbols, sort, period, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns premium index candles for a certain contract.
         * @summary Premium index candles for a contract.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [period] 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesCandlesPremiumIndexSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Candle>>> {
            return MarketDataApiFp(configuration).publicFuturesCandlesPremiumIndexSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns funding history for all or multiple contracts.
         * @summary Get funding history.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesHistoryFundingGet(symbols?: Array<string>, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FundingHistoryMulti>> {
            return MarketDataApiFp(configuration).publicFuturesHistoryFundingGet(symbols, sort, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns funding history for a specific contract.
         * @summary Get funding history.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesHistoryFundingSymbolGet(symbol: string, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<FundingHistoryMulti>> {
            return MarketDataApiFp(configuration).publicFuturesHistoryFundingSymbolGet(symbol, sort, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns futures information for all or multiple contracts.
         * @summary Get futures information.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesInfoGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesInfoMulti>> {
            return MarketDataApiFp(configuration).publicFuturesInfoGet(symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns futures information for a specified contract.
         * @summary Get futures information for a contract.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicFuturesInfoSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<FuturesInfo>> {
            return MarketDataApiFp(configuration).publicFuturesInfoSymbolGet(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns order book for all or multiple symbols.
         * @summary Get order books.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicOrderbookGet(symbols?: Array<string>, depth?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<OrderbookMulti>> {
            return MarketDataApiFp(configuration).publicOrderbookGet(symbols, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * The request returns an order book for a specific symbol.
         * @summary Get order book by symbol.
         * @param {string} symbol Symbol code.
         * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
         * @param {number} [volume] Desired volume for market depth search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicOrderbookSymbolGet(symbol: string, depth?: number, volume?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Orderbook>> {
            return MarketDataApiFp(configuration).publicOrderbookSymbolGet(symbol, depth, volume, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns quotation prices history.
         * @summary Get prices history.
         * @param {string} to Target currency code.
         * @param {string} [from] Source currency code.
         * @param {string} [since] Interval initial value.
         * @param {string} [until] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {string} [period] 
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceHistoryGet(to: string, from?: string, since?: string, until?: string, limit?: number, period?: string, sort?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<PriceHistoryMulti>> {
            return MarketDataApiFp(configuration).publicPriceHistoryGet(to, from, since, until, limit, period, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns currencies quotation prices.
         * @summary Get prices.
         * @param {string} from Source currency code.
         * @param {string} to Target currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceRateGet(from: string, to: string, options?: AxiosRequestConfig): Promise<AxiosResponse<PriceMulti>> {
            return MarketDataApiFp(configuration).publicPriceRateGet(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns tickers' last prices for all symbols.
         * @summary Get ticker last prices.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<AxiosResponse<TickerPriceMulti>> {
            return MarketDataApiFp(configuration).publicPriceTickerGet(symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the ticker last price for a specific symbol.
         * @summary Get ticker last price by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPriceTickerSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<TickerPrice>> {
            return MarketDataApiFp(configuration).publicPriceTickerSymbolGet(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the actual list of currency symbols (currency pairs) traded on the exchange.
         * @summary Get symbols.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicSymbolGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
            return MarketDataApiFp(configuration).publicSymbolGet(symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicSymbolSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2001>> {
            return MarketDataApiFp(configuration).publicSymbolSymbolGet(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns ticker information.
         * @summary Get tickers.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig): Promise<AxiosResponse<TickerMulti>> {
            return MarketDataApiFp(configuration).publicTickerGet(symbols, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the ticker for a specific symbol.
         * @summary Get ticker by symbol.
         * @param {string} symbol Symbol code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTickerSymbolGet(symbol: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Ticker>> {
            return MarketDataApiFp(configuration).publicTickerSymbolGet(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns trades information for all or multiple symbols.
         * @summary Get trades.
         * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
         * @param {string} [by] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTradesGet(symbols?: Array<string>, by?: string, sort?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PublicTradeMulti>>> {
            return MarketDataApiFp(configuration).publicTradesGet(symbols, by, sort, from, till, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns trades information for a specific symbol.
         * @param {string} symbol Symbol code.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {string} [by] The name of the field to order the results by.
         * @param {Date} [from] Interval initial value.
         * @param {Date} [till] Interval end value.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicTradesSymbolGet(symbol: string, sort?: string, by?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<PublicTrade>>> {
            return MarketDataApiFp(configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
export class MarketDataApi extends BaseAPI {
    /**
     * Returns candles for all or multiple symbols.
     * @summary Get candles.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicCandlesGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<CandleMulti>> {
        return MarketDataApiFp(this.configuration).publicCandlesGet(symbols, sort, period, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns candles for a specific symbol.
     * @summary Get candles for a specific symbol.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicCandlesSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Candle>>> {
        return MarketDataApiFp(this.configuration).publicCandlesSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get currency.
     * @param {string} currency Currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicCurrencyCurrencyGet(currency: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Currency>> {
        return MarketDataApiFp(this.configuration).publicCurrencyCurrencyGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the actual list of available currencies, tokens, etc.
     * @summary Get —Åurrencies.
     * @param {Array<string>} [currencies] Comma-separated list of currency codes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicCurrencyGet(currencies?: Array<string>, options?: AxiosRequestConfig) : Promise<AxiosResponse<CurrencyMulti>> {
        return MarketDataApiFp(this.configuration).publicCurrencyGet(currencies, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns index price candles for all or multiple contracts.
     * @summary Get index price candles.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesIndexPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesCandleMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesIndexPriceGet(symbols, sort, period, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns index price candles for a specific contract.
     * @summary Get index price candles for a contract.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesIndexPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Candle>>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesIndexPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns mark price candles for all or multiple contracts.
     * @summary Get mark price candles.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesMarkPriceGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesCandleMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesMarkPriceGet(symbols, sort, period, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns mark price candles for a specific contract.
     * @summary Get mark price candles for a contract.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesMarkPriceSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Candle>>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesMarkPriceSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns open interest candles for all or multiple contracts.
     * @summary Get open interest candles.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesOpenInterestGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesCandleMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesOpenInterestGet(symbols, sort, period, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns open interest candles for a specific symbol.
     * @summary Get open interest candles for a specific symbol.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesOpenInterestSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Candle>>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesOpenInterestSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns premium index candles for all or multiple contracts.
     * @summary Get premium index candles.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesPremiumIndexGet(symbols?: Array<string>, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesCandleMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesPremiumIndexGet(symbols, sort, period, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns premium index candles for a certain contract.
     * @summary Premium index candles for a contract.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [period] 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesCandlesPremiumIndexSymbolGet(symbol: string, sort?: string, period?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Candle>>> {
        return MarketDataApiFp(this.configuration).publicFuturesCandlesPremiumIndexSymbolGet(symbol, sort, period, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns funding history for all or multiple contracts.
     * @summary Get funding history.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesHistoryFundingGet(symbols?: Array<string>, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FundingHistoryMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesHistoryFundingGet(symbols, sort, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns funding history for a specific contract.
     * @summary Get funding history.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesHistoryFundingSymbolGet(symbol: string, sort?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<FundingHistoryMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesHistoryFundingSymbolGet(symbol, sort, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns futures information for all or multiple contracts.
     * @summary Get futures information.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesInfoGet(symbols?: Array<string>, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesInfoMulti>> {
        return MarketDataApiFp(this.configuration).publicFuturesInfoGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns futures information for a specified contract.
     * @summary Get futures information for a contract.
     * @param {string} symbol Symbol code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicFuturesInfoSymbolGet(symbol: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<FuturesInfo>> {
        return MarketDataApiFp(this.configuration).publicFuturesInfoSymbolGet(symbol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns order book for all or multiple symbols.
     * @summary Get order books.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicOrderbookGet(symbols?: Array<string>, depth?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<OrderbookMulti>> {
        return MarketDataApiFp(this.configuration).publicOrderbookGet(symbols, depth, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The request returns an order book for a specific symbol.
     * @summary Get order book by symbol.
     * @param {string} symbol Symbol code.
     * @param {number} [depth] Order book depth. Set to &#x60;0&#x60; to view the full order book.
     * @param {number} [volume] Desired volume for market depth search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicOrderbookSymbolGet(symbol: string, depth?: number, volume?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Orderbook>> {
        return MarketDataApiFp(this.configuration).publicOrderbookSymbolGet(symbol, depth, volume, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns quotation prices history.
     * @summary Get prices history.
     * @param {string} to Target currency code.
     * @param {string} [from] Source currency code.
     * @param {string} [since] Interval initial value.
     * @param {string} [until] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {string} [period] 
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicPriceHistoryGet(to: string, from?: string, since?: string, until?: string, limit?: number, period?: string, sort?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<PriceHistoryMulti>> {
        return MarketDataApiFp(this.configuration).publicPriceHistoryGet(to, from, since, until, limit, period, sort, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns currencies quotation prices.
     * @summary Get prices.
     * @param {string} from Source currency code.
     * @param {string} to Target currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicPriceRateGet(from: string, to: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<PriceMulti>> {
        return MarketDataApiFp(this.configuration).publicPriceRateGet(from, to, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns tickers' last prices for all symbols.
     * @summary Get ticker last prices.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicPriceTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig) : Promise<AxiosResponse<TickerPriceMulti>> {
        return MarketDataApiFp(this.configuration).publicPriceTickerGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the ticker last price for a specific symbol.
     * @summary Get ticker last price by symbol.
     * @param {string} symbol Symbol code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicPriceTickerSymbolGet(symbol: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<TickerPrice>> {
        return MarketDataApiFp(this.configuration).publicPriceTickerSymbolGet(symbol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the actual list of currency symbols (currency pairs) traded on the exchange.
     * @summary Get symbols.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicSymbolGet(symbols?: Array<string>, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200>> {
        return MarketDataApiFp(this.configuration).publicSymbolGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a specific symbol.
     * @param {string} symbol Symbol code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicSymbolSymbolGet(symbol: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2001>> {
        return MarketDataApiFp(this.configuration).publicSymbolSymbolGet(symbol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns ticker information.
     * @summary Get tickers.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicTickerGet(symbols?: Array<string>, options?: AxiosRequestConfig) : Promise<AxiosResponse<TickerMulti>> {
        return MarketDataApiFp(this.configuration).publicTickerGet(symbols, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the ticker for a specific symbol.
     * @summary Get ticker by symbol.
     * @param {string} symbol Symbol code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicTickerSymbolGet(symbol: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Ticker>> {
        return MarketDataApiFp(this.configuration).publicTickerSymbolGet(symbol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns trades information for all or multiple symbols.
     * @summary Get trades.
     * @param {Array<string>} [symbols] Comma-separated list of symbol codes.
     * @param {string} [by] The name of the field to order the results by.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicTradesGet(symbols?: Array<string>, by?: string, sort?: string, from?: Date, till?: Date, limit?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PublicTradeMulti>>> {
        return MarketDataApiFp(this.configuration).publicTradesGet(symbols, by, sort, from, till, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Returns trades information for a specific symbol.
     * @param {string} symbol Symbol code.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {string} [by] The name of the field to order the results by.
     * @param {Date} [from] Interval initial value.
     * @param {Date} [till] Interval end value.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    public async publicTradesSymbolGet(symbol: string, sort?: string, by?: string, from?: Date, till?: Date, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<PublicTrade>>> {
        return MarketDataApiFp(this.configuration).publicTradesSymbolGet(symbol, sort, by, from, till, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}
