/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Create API keys in your profile and use public API key as username and secret API key as password to authorize.
 *
 * 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Airdrop } from '../models';
import { AmountLock } from '../models';
import { InlineResponse20010 } from '../models';
import { InlineResponse20011 } from '../models';
import { InlineResponse2007 } from '../models';
import { InlineResponse2008 } from '../models';
import { InlineResponse2009 } from '../models';
import { Result } from '../models';
import { Transaction } from '../models';
import { TransactionHistory } from '../models';
import { WalletAddress } from '../models';
import { WalletBalance } from '../models';
/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the airdrops.
         * @param {string} [currency] The code of dropped currency.
         * @param {string} [baseCurrency] The code of base currency (the currency used for dropped currency amount calculation).
         * @param {string} [activeAt] The request returns airdrops, active at the specified moment (default now).
         * @param {Array<string>} [statuses] An array of desired airdrop statuses.
         * @param {string} [transactionId] An airdrop transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletAirdropsGet: async (currency?: string, baseCurrency?: string, activeAt?: string, statuses?: Array<string>, transactionId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/airdrops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (baseCurrency !== undefined) {
                localVarQueryParameter['base_currency'] = baseCurrency;
            }

            if (activeAt !== undefined) {
                localVarQueryParameter['active_at'] = activeAt;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transaction_id'] = transactionId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Claim an airdrop.
         * @param {string} id Airdrop identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletAirdropsIdClaimPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletAirdropsIdClaimPost.');
            }
            const localVarPath = `/wallet/airdrops/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Amount locks allow to set the minimum user's balance to determine their solvency. The locked amount is not displayed in user's balances.  Amount locks are not tied to a currency. All locks in total affect the ability to withdraw the balance in any currency. 
         * @summary Returns a list of amount locks.
         * @param {string} [currency] Currency code.
         * @param {boolean} [active] Defines whether the lock is active.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletAmountLocksGet: async (currency?: string, active?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/amount-locks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user's wallet balance per currency.
         * @summary Wallet balance per currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceCurrencyGet: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletBalanceCurrencyGet.');
            }
            const localVarPath = `/wallet/balance/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user's wallet balances except zero balances.
         * @summary Wallet balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalanceGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Convert between currencies.
         * @param {string} fromCurrency 
         * @param {string} toCurrency 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletConvertPostForm: async (fromCurrency: string, toCurrency: string, amount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromCurrency' is not null or undefined
            if (fromCurrency === null || fromCurrency === undefined) {
                throw new RequiredError('fromCurrency','Required parameter fromCurrency was null or undefined when calling walletConvertPostForm.');
            }
            // verify required parameter 'toCurrency' is not null or undefined
            if (toCurrency === null || toCurrency === undefined) {
                throw new RequiredError('toCurrency','Required parameter toCurrency was null or undefined when calling walletConvertPostForm.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling walletConvertPostForm.');
            }
            const localVarPath = `/wallet/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication BasicAuth required


            if (fromCurrency !== undefined) { 
                localVarFormParams.set('from_currency', fromCurrency as any);
            }

            if (toCurrency !== undefined) { 
                localVarFormParams.set('to_currency', toCurrency as any);
            }

            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a crypto address belongs to the current account.
         * @param {string} address Crypto address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoAddressCheckMineGet: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling walletCryptoAddressCheckMineGet.');
            }
            const localVarPath = `/wallet/crypto/address/check-mine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all deposit crypto addresses.
         * @summary Get all deposit crypto addresses.
         * @param {string} [currency] Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoAddressGet: async (currency?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/crypto/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new deposit address. Existing addresses may still receive funds. For some tokens (e.g., Ethereum tokens), a single address is generated per base currency with additional identifiers which differ for each address: `payment_id` or `public_key`. As a result, generating a new address for such token will change the current address for an entire base currency accordingly. 
         * @summary Deposit crypto address.
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoAddressPostForm: async (currency?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/crypto/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication BasicAuth required


            if (currency !== undefined) { 
                localVarFormParams.set('currency', currency as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last 10 unique addresses used for deposits (by currency).
         * @summary Get the last 10 deposit crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoAddressRecentDepositGet: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletCryptoAddressRecentDepositGet.');
            }
            const localVarPath = `/wallet/crypto/address/recent-deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last 10 unique addresses used for withdrawals (by currency).
         * @summary Get the last 10 withdrawal crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoAddressRecentWithdrawGet: async (currency: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletCryptoAddressRecentWithdrawGet.');
            }
            const localVarPath = `/wallet/crypto/address/recent-withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check the offchain availability.
         * @param {string} currency 
         * @param {string} address 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoCheckOffchainAvailablePostForm: async (currency: string, address: string, paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletCryptoCheckOffchainAvailablePostForm.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling walletCryptoCheckOffchainAvailablePostForm.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling walletCryptoCheckOffchainAvailablePostForm.');
            }
            const localVarPath = `/wallet/crypto/check-offchain-available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication BasicAuth required


            if (currency !== undefined) { 
                localVarFormParams.set('currency', currency as any);
            }

            if (address !== undefined) { 
                localVarFormParams.set('address', address as any);
            }

            if (paymentId !== undefined) { 
                localVarFormParams.set('paymentId', paymentId as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Estimate fee for withdrawal.
         * @param {string} currency Currency code.
         * @param {string} amount The amount that will be withdrawn.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoFeeEstimateGet: async (currency: string, amount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletCryptoFeeEstimateGet.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling walletCryptoFeeEstimateGet.');
            }
            const localVarPath = `/wallet/crypto/fee/estimate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Roll back a withdrawal.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoWithdrawIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletCryptoWithdrawIdDelete.');
            }
            const localVarPath = `/wallet/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Commit a withdrawal. The transaction gets the status `PENDING`.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoWithdrawIdPut: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletCryptoWithdrawIdPut.');
            }
            const localVarPath = `/wallet/crypto/withdraw/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Withdraw crypto. The transaction gets the status `CREATED` right after the creation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCryptoWithdrawPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/crypto/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer money to another user.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} by 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletInternalWithdrawPostForm: async (currency: string, amount: string, by: string, identifier: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletInternalWithdrawPostForm.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling walletInternalWithdrawPostForm.');
            }
            // verify required parameter 'by' is not null or undefined
            if (by === null || by === undefined) {
                throw new RequiredError('by','Required parameter by was null or undefined when calling walletInternalWithdrawPostForm.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling walletInternalWithdrawPostForm.');
            }
            const localVarPath = `/wallet/internal/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication BasicAuth required


            if (currency !== undefined) { 
                localVarFormParams.set('currency', currency as any);
            }

            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }

            if (by !== undefined) { 
                localVarFormParams.set('by', by as any);
            }

            if (identifier !== undefined) { 
                localVarFormParams.set('identifier', identifier as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactions' history.
         * @param {Date} [from] The earliest transaction date.
         * @param {Date} [till] The latest transaction date.
         * @param {Array<string>} [statuses] Comma-separated list of transaction statuses.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {string} [idFrom] The initial transaction identifier on the list.
         * @param {string} [idTill] The final transaction identifier on the list.
         * @param {string} [txIds] Comma-separated list of transactions&#x27; bank identifiers.
         * @param {string} [orderBy] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionsGet: async (from?: Date, till?: Date, statuses?: Array<string>, currencies?: Array<string>, idFrom?: string, idTill?: string, txIds?: string, orderBy?: string, sort?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallet/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (till !== undefined) {
                localVarQueryParameter['till'] = (till as any instanceof Date) ?
                    (till as any).toISOString() :
                    till;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
            }

            if (currencies) {
                localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
            }

            if (idFrom !== undefined) {
                localVarQueryParameter['id_from'] = idFrom;
            }

            if (idTill !== undefined) {
                localVarQueryParameter['id_till'] = idTill;
            }

            if (txIds !== undefined) {
                localVarQueryParameter['tx_ids'] = txIds;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a transaction by Id.
         * @param {string} txId Transaction bank identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionsTxIdGet: async (txId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txId' is not null or undefined
            if (txId === null || txId === undefined) {
                throw new RequiredError('txId','Required parameter txId was null or undefined when calling walletTransactionsTxIdGet.');
            }
            const localVarPath = `/wallet/transactions/{tx_id}`
                .replace(`{${"tx_id"}}`, encodeURIComponent(String(txId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer between wallet and exchange.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} source 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransferPostForm: async (currency: string, amount: string, source: string, destination: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling walletTransferPostForm.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling walletTransferPostForm.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling walletTransferPostForm.');
            }
            // verify required parameter 'destination' is not null or undefined
            if (destination === null || destination === undefined) {
                throw new RequiredError('destination','Required parameter destination was null or undefined when calling walletTransferPostForm.');
            }
            const localVarPath = `/wallet/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication BasicAuth required


            if (currency !== undefined) { 
                localVarFormParams.set('currency', currency as any);
            }

            if (amount !== undefined) { 
                localVarFormParams.set('amount', amount as any);
            }

            if (source !== undefined) { 
                localVarFormParams.set('source', source as any);
            }

            if (destination !== undefined) { 
                localVarFormParams.set('destination', destination as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the airdrops.
         * @param {string} [currency] The code of dropped currency.
         * @param {string} [baseCurrency] The code of base currency (the currency used for dropped currency amount calculation).
         * @param {string} [activeAt] The request returns airdrops, active at the specified moment (default now).
         * @param {Array<string>} [statuses] An array of desired airdrop statuses.
         * @param {string} [transactionId] An airdrop transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAirdropsGet(currency?: string, baseCurrency?: string, activeAt?: string, statuses?: Array<string>, transactionId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Airdrop>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletAirdropsGet(currency, baseCurrency, activeAt, statuses, transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Claim an airdrop.
         * @param {string} id Airdrop identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAirdropsIdClaimPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletAirdropsIdClaimPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Amount locks allow to set the minimum user's balance to determine their solvency. The locked amount is not displayed in user's balances.  Amount locks are not tied to a currency. All locks in total affect the ability to withdraw the balance in any currency. 
         * @summary Returns a list of amount locks.
         * @param {string} [currency] Currency code.
         * @param {boolean} [active] Defines whether the lock is active.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAmountLocksGet(currency?: string, active?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<AmountLock>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletAmountLocksGet(currency, active, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the user's wallet balance per currency.
         * @summary Wallet balance per currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceCurrencyGet(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2007>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletBalanceCurrencyGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the user's wallet balances except zero balances.
         * @summary Wallet balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<WalletBalance>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletBalanceGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Convert between currencies.
         * @param {string} fromCurrency 
         * @param {string} toCurrency 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletConvertPostForm(fromCurrency: string, toCurrency: string, amount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2008>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletConvertPostForm(fromCurrency, toCurrency, amount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check whether a crypto address belongs to the current account.
         * @param {string} address Crypto address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressCheckMineGet(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Result>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoAddressCheckMineGet(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all deposit crypto addresses.
         * @summary Get all deposit crypto addresses.
         * @param {string} [currency] Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressGet(currency?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<WalletAddress>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoAddressGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new deposit address. Existing addresses may still receive funds. For some tokens (e.g., Ethereum tokens), a single address is generated per base currency with additional identifiers which differ for each address: `payment_id` or `public_key`. As a result, generating a new address for such token will change the current address for an entire base currency accordingly. 
         * @summary Deposit crypto address.
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressPostForm(currency?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WalletAddress>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoAddressPostForm(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the last 10 unique addresses used for deposits (by currency).
         * @summary Get the last 10 deposit crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressRecentDepositGet(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<WalletAddress>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoAddressRecentDepositGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the last 10 unique addresses used for withdrawals (by currency).
         * @summary Get the last 10 withdrawal crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressRecentWithdrawGet(currency: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<WalletAddress>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoAddressRecentWithdrawGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Check the offchain availability.
         * @param {string} currency 
         * @param {string} address 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoCheckOffchainAvailablePostForm(currency: string, address: string, paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Result>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoCheckOffchainAvailablePostForm(currency, address, paymentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Estimate fee for withdrawal.
         * @param {string} currency Currency code.
         * @param {string} amount The amount that will be withdrawn.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoFeeEstimateGet(currency: string, amount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20011>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoFeeEstimateGet(currency, amount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Roll back a withdrawal.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Result>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoWithdrawIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Commit a withdrawal. The transaction gets the status `PENDING`.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawIdPut(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Result>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoWithdrawIdPut(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Withdraw crypto. The transaction gets the status `CREATED` right after the creation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Transaction>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletCryptoWithdrawPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Transfer money to another user.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} by 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletInternalWithdrawPostForm(currency: string, amount: string, by: string, identifier: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2009>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletInternalWithdrawPostForm(currency, amount, by, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get transactions' history.
         * @param {Date} [from] The earliest transaction date.
         * @param {Date} [till] The latest transaction date.
         * @param {Array<string>} [statuses] Comma-separated list of transaction statuses.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {string} [idFrom] The initial transaction identifier on the list.
         * @param {string} [idTill] The final transaction identifier on the list.
         * @param {string} [txIds] Comma-separated list of transactions&#x27; bank identifiers.
         * @param {string} [orderBy] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransactionsGet(from?: Date, till?: Date, statuses?: Array<string>, currencies?: Array<string>, idFrom?: string, idTill?: string, txIds?: string, orderBy?: string, sort?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<TransactionHistory>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletTransactionsGet(from, till, statuses, currencies, idFrom, idTill, txIds, orderBy, sort, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a transaction by Id.
         * @param {string} txId Transaction bank identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransactionsTxIdGet(txId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20010>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletTransactionsTxIdGet(txId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Transfer between wallet and exchange.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} source 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransferPostForm(currency: string, amount: string, source: string, destination: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<string>>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).walletTransferPostForm(currency, amount, source, destination, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the airdrops.
         * @param {string} [currency] The code of dropped currency.
         * @param {string} [baseCurrency] The code of base currency (the currency used for dropped currency amount calculation).
         * @param {string} [activeAt] The request returns airdrops, active at the specified moment (default now).
         * @param {Array<string>} [statuses] An array of desired airdrop statuses.
         * @param {string} [transactionId] An airdrop transaction identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAirdropsGet(currency?: string, baseCurrency?: string, activeAt?: string, statuses?: Array<string>, transactionId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Airdrop>>> {
            return WalletApiFp(configuration).walletAirdropsGet(currency, baseCurrency, activeAt, statuses, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Claim an airdrop.
         * @param {string} id Airdrop identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAirdropsIdClaimPost(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return WalletApiFp(configuration).walletAirdropsIdClaimPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Amount locks allow to set the minimum user's balance to determine their solvency. The locked amount is not displayed in user's balances.  Amount locks are not tied to a currency. All locks in total affect the ability to withdraw the balance in any currency. 
         * @summary Returns a list of amount locks.
         * @param {string} [currency] Currency code.
         * @param {boolean} [active] Defines whether the lock is active.
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletAmountLocksGet(currency?: string, active?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<AmountLock>>> {
            return WalletApiFp(configuration).walletAmountLocksGet(currency, active, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user's wallet balance per currency.
         * @summary Wallet balance per currency.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceCurrencyGet(currency: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2007>> {
            return WalletApiFp(configuration).walletBalanceCurrencyGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user's wallet balances except zero balances.
         * @summary Wallet balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletBalanceGet(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<WalletBalance>>> {
            return WalletApiFp(configuration).walletBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Convert between currencies.
         * @param {string} fromCurrency 
         * @param {string} toCurrency 
         * @param {string} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletConvertPostForm(fromCurrency: string, toCurrency: string, amount: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2008>> {
            return WalletApiFp(configuration).walletConvertPostForm(fromCurrency, toCurrency, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check whether a crypto address belongs to the current account.
         * @param {string} address Crypto address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressCheckMineGet(address: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Result>> {
            return WalletApiFp(configuration).walletCryptoAddressCheckMineGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all deposit crypto addresses.
         * @summary Get all deposit crypto addresses.
         * @param {string} [currency] Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressGet(currency?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<WalletAddress>>> {
            return WalletApiFp(configuration).walletCryptoAddressGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new deposit address. Existing addresses may still receive funds. For some tokens (e.g., Ethereum tokens), a single address is generated per base currency with additional identifiers which differ for each address: `payment_id` or `public_key`. As a result, generating a new address for such token will change the current address for an entire base currency accordingly. 
         * @summary Deposit crypto address.
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressPostForm(currency?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<WalletAddress>> {
            return WalletApiFp(configuration).walletCryptoAddressPostForm(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last 10 unique addresses used for deposits (by currency).
         * @summary Get the last 10 deposit crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressRecentDepositGet(currency: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<WalletAddress>>> {
            return WalletApiFp(configuration).walletCryptoAddressRecentDepositGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last 10 unique addresses used for withdrawals (by currency).
         * @summary Get the last 10 withdrawal crypto addresses.
         * @param {string} currency Currency code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoAddressRecentWithdrawGet(currency: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<WalletAddress>>> {
            return WalletApiFp(configuration).walletCryptoAddressRecentWithdrawGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check the offchain availability.
         * @param {string} currency 
         * @param {string} address 
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoCheckOffchainAvailablePostForm(currency: string, address: string, paymentId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Result>> {
            return WalletApiFp(configuration).walletCryptoCheckOffchainAvailablePostForm(currency, address, paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Estimate fee for withdrawal.
         * @param {string} currency Currency code.
         * @param {string} amount The amount that will be withdrawn.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoFeeEstimateGet(currency: string, amount: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20011>> {
            return WalletApiFp(configuration).walletCryptoFeeEstimateGet(currency, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Roll back a withdrawal.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawIdDelete(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Result>> {
            return WalletApiFp(configuration).walletCryptoWithdrawIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Commit a withdrawal. The transaction gets the status `PENDING`.
         * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawIdPut(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Result>> {
            return WalletApiFp(configuration).walletCryptoWithdrawIdPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Withdraw crypto. The transaction gets the status `CREATED` right after the creation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletCryptoWithdrawPost(options?: AxiosRequestConfig): Promise<AxiosResponse<Transaction>> {
            return WalletApiFp(configuration).walletCryptoWithdrawPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer money to another user.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} by 
         * @param {string} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletInternalWithdrawPostForm(currency: string, amount: string, by: string, identifier: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2009>> {
            return WalletApiFp(configuration).walletInternalWithdrawPostForm(currency, amount, by, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transactions' history.
         * @param {Date} [from] The earliest transaction date.
         * @param {Date} [till] The latest transaction date.
         * @param {Array<string>} [statuses] Comma-separated list of transaction statuses.
         * @param {Array<string>} [currencies] Comma-separated list of currency codes.
         * @param {string} [idFrom] The initial transaction identifier on the list.
         * @param {string} [idTill] The final transaction identifier on the list.
         * @param {string} [txIds] Comma-separated list of transactions&#x27; bank identifiers.
         * @param {string} [orderBy] The name of the field to order the results by.
         * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
         * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
         * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransactionsGet(from?: Date, till?: Date, statuses?: Array<string>, currencies?: Array<string>, idFrom?: string, idTill?: string, txIds?: string, orderBy?: string, sort?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<TransactionHistory>>> {
            return WalletApiFp(configuration).walletTransactionsGet(from, till, statuses, currencies, idFrom, idTill, txIds, orderBy, sort, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a transaction by Id.
         * @param {string} txId Transaction bank identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransactionsTxIdGet(txId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20010>> {
            return WalletApiFp(configuration).walletTransactionsTxIdGet(txId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer between wallet and exchange.
         * @param {string} currency 
         * @param {string} amount 
         * @param {string} source 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletTransferPostForm(currency: string, amount: string, source: string, destination: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<string>>> {
            return WalletApiFp(configuration).walletTransferPostForm(currency, amount, source, destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Get the airdrops.
     * @param {string} [currency] The code of dropped currency.
     * @param {string} [baseCurrency] The code of base currency (the currency used for dropped currency amount calculation).
     * @param {string} [activeAt] The request returns airdrops, active at the specified moment (default now).
     * @param {Array<string>} [statuses] An array of desired airdrop statuses.
     * @param {string} [transactionId] An airdrop transaction identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletAirdropsGet(currency?: string, baseCurrency?: string, activeAt?: string, statuses?: Array<string>, transactionId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Airdrop>>> {
        return WalletApiFp(this.configuration).walletAirdropsGet(currency, baseCurrency, activeAt, statuses, transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Claim an airdrop.
     * @param {string} id Airdrop identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletAirdropsIdClaimPost(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return WalletApiFp(this.configuration).walletAirdropsIdClaimPost(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Amount locks allow to set the minimum user's balance to determine their solvency. The locked amount is not displayed in user's balances.  Amount locks are not tied to a currency. All locks in total affect the ability to withdraw the balance in any currency. 
     * @summary Returns a list of amount locks.
     * @param {string} [currency] Currency code.
     * @param {boolean} [active] Defines whether the lock is active.
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletAmountLocksGet(currency?: string, active?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<AmountLock>>> {
        return WalletApiFp(this.configuration).walletAmountLocksGet(currency, active, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the user's wallet balance per currency.
     * @summary Wallet balance per currency.
     * @param {string} currency Currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletBalanceCurrencyGet(currency: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2007>> {
        return WalletApiFp(this.configuration).walletBalanceCurrencyGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the user's wallet balances except zero balances.
     * @summary Wallet balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletBalanceGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<WalletBalance>>> {
        return WalletApiFp(this.configuration).walletBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Convert between currencies.
     * @param {string} fromCurrency 
     * @param {string} toCurrency 
     * @param {string} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletConvertPostForm(fromCurrency: string, toCurrency: string, amount: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2008>> {
        return WalletApiFp(this.configuration).walletConvertPostForm(fromCurrency, toCurrency, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check whether a crypto address belongs to the current account.
     * @param {string} address Crypto address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoAddressCheckMineGet(address: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Result>> {
        return WalletApiFp(this.configuration).walletCryptoAddressCheckMineGet(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all deposit crypto addresses.
     * @summary Get all deposit crypto addresses.
     * @param {string} [currency] Currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoAddressGet(currency?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<WalletAddress>>> {
        return WalletApiFp(this.configuration).walletCryptoAddressGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new deposit address. Existing addresses may still receive funds. For some tokens (e.g., Ethereum tokens), a single address is generated per base currency with additional identifiers which differ for each address: `payment_id` or `public_key`. As a result, generating a new address for such token will change the current address for an entire base currency accordingly. 
     * @summary Deposit crypto address.
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoAddressPostForm(currency?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<WalletAddress>> {
        return WalletApiFp(this.configuration).walletCryptoAddressPostForm(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the last 10 unique addresses used for deposits (by currency).
     * @summary Get the last 10 deposit crypto addresses.
     * @param {string} currency Currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoAddressRecentDepositGet(currency: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<WalletAddress>>> {
        return WalletApiFp(this.configuration).walletCryptoAddressRecentDepositGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the last 10 unique addresses used for withdrawals (by currency).
     * @summary Get the last 10 withdrawal crypto addresses.
     * @param {string} currency Currency code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoAddressRecentWithdrawGet(currency: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<WalletAddress>>> {
        return WalletApiFp(this.configuration).walletCryptoAddressRecentWithdrawGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Check the offchain availability.
     * @param {string} currency 
     * @param {string} address 
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoCheckOffchainAvailablePostForm(currency: string, address: string, paymentId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Result>> {
        return WalletApiFp(this.configuration).walletCryptoCheckOffchainAvailablePostForm(currency, address, paymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Estimate fee for withdrawal.
     * @param {string} currency Currency code.
     * @param {string} amount The amount that will be withdrawn.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoFeeEstimateGet(currency: string, amount: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20011>> {
        return WalletApiFp(this.configuration).walletCryptoFeeEstimateGet(currency, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Roll back a withdrawal.
     * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoWithdrawIdDelete(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Result>> {
        return WalletApiFp(this.configuration).walletCryptoWithdrawIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Commit a withdrawal. The transaction gets the status `PENDING`.
     * @param {string} id Transaction unique identifier returned to a &#x60;POST /api/3/wallet/crypto/withdraw&#x60; request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoWithdrawIdPut(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Result>> {
        return WalletApiFp(this.configuration).walletCryptoWithdrawIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Withdraw crypto. The transaction gets the status `CREATED` right after the creation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletCryptoWithdrawPost(options?: AxiosRequestConfig) : Promise<AxiosResponse<Transaction>> {
        return WalletApiFp(this.configuration).walletCryptoWithdrawPost(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Transfer money to another user.
     * @param {string} currency 
     * @param {string} amount 
     * @param {string} by 
     * @param {string} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletInternalWithdrawPostForm(currency: string, amount: string, by: string, identifier: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2009>> {
        return WalletApiFp(this.configuration).walletInternalWithdrawPostForm(currency, amount, by, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get transactions' history.
     * @param {Date} [from] The earliest transaction date.
     * @param {Date} [till] The latest transaction date.
     * @param {Array<string>} [statuses] Comma-separated list of transaction statuses.
     * @param {Array<string>} [currencies] Comma-separated list of currency codes.
     * @param {string} [idFrom] The initial transaction identifier on the list.
     * @param {string} [idTill] The final transaction identifier on the list.
     * @param {string} [txIds] Comma-separated list of transactions&#x27; bank identifiers.
     * @param {string} [orderBy] The name of the field to order the results by.
     * @param {string} [sort] Sort order:  * Ascending, from A to Z.  * Descending, from Z to A. 
     * @param {number} [limit] The number of items to return. The limit can range between *1* and *1000*. 
     * @param {number} [offset] The number of items to skip before starting to collect the result set. Offset can range between *0* and *100000*. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletTransactionsGet(from?: Date, till?: Date, statuses?: Array<string>, currencies?: Array<string>, idFrom?: string, idTill?: string, txIds?: string, orderBy?: string, sort?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<TransactionHistory>>> {
        return WalletApiFp(this.configuration).walletTransactionsGet(from, till, statuses, currencies, idFrom, idTill, txIds, orderBy, sort, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a transaction by Id.
     * @param {string} txId Transaction bank identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletTransactionsTxIdGet(txId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20010>> {
        return WalletApiFp(this.configuration).walletTransactionsTxIdGet(txId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Transfer between wallet and exchange.
     * @param {string} currency 
     * @param {string} amount 
     * @param {string} source 
     * @param {string} destination 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async walletTransferPostForm(currency: string, amount: string, source: string, destination: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<string>>> {
        return WalletApiFp(this.configuration).walletTransferPostForm(currency, amount, source, destination, options).then((request) => request(this.axios, this.basePath));
    }
}
